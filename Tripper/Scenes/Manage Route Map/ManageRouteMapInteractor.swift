//
//  ManageRouteMapInteractor.swift
//  Tripper
//
//  Created by Denis Cherniy on 07.04.2020.
//  Copyright (c) 2020 Denis Cherniy. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation

protocol ManageRouteMapBusinessLogic {
    func fetchNewAnnotationsInfo(request: ManageRouteMap.FetchNewAnnotationsInfo.Request)
    func createRoutePoint(request: ManageRouteMap.CreateRoutePoint.Request)
    func setRoutePoint(request: ManageRouteMap.SetRoutePoint.Request)
    func selectAnnotation(request: ManageRouteMap.SelectAnnotation.Request)
    func deselectAnnotation(request: ManageRouteMap.DeselectAnnotation.Request)
    func showDetail(request: ManageRouteMap.ShowDetail.Request)
    func editRoutePoint(request: ManageRouteMap.EditRoutePoint.Request)
    func deleteRoutePoint(request: ManageRouteMap.DeleteAnnotation.Request)
    func createRouteFragment(request: ManageRouteMap.CreateRouteFragment.Request)
    func deleteRouteFragment(request: ManageRouteMap.DeleteRouteFragment.Request)
    func mapRoute(request: ManageRouteMap.MapRoute.Request)
}

protocol ManageRouteMapDataStore {
    var tappedCoordinate: CLLocationCoordinate2D? { get set }
    var idOfSelectedAnnotation: String? { get set }
    var selectedRoutePoint: RoutePoint? { get set }
    var routePointToEdit: RoutePoint? { get set }
}

class ManageRouteMapInteractor: ManageRouteMapBusinessLogic, ManageRouteMapDataStore {
    var presenter: ManageRouteMapPresentationLogic?
    var worker: ManageRouteMapWorker?
    var routeCreator: MapboxRouteCreator?

    var idOfSelectedAnnotation: String?
    
    // IF YOU ARE GOING TO DELETE THIS REMEMBER THERE ARE A LOT OF DEPENDENCIES.
    var selectedRoutePoint: RoutePoint? {
        get {
            
            // TODO: Unreliable implementation.
            if let id = idOfSelectedAnnotation {
                return worker?.fetchRoutePoint(with: id)
            } else {
                return nil
            }
        }
        
        set {
            idOfSelectedAnnotation = newValue?.id
        }
    }
    
    init() {
        annotationsInfo = []
    }
    
    // MARK: - Create route point
    
    var tappedCoordinate: CLLocationCoordinate2D?
    
    func createRoutePoint(request: ManageRouteMap.CreateRoutePoint.Request) {        
        tappedCoordinate = CLLocationCoordinate2D(latitude: request.latitude, longitude: request.longitude)
        let response = ManageRouteMap.CreateRoutePoint.Response()
        presenter?.presentAnnotationCreation(response: response)
    }
    
    // MARK: Fetch new annotations info
    var annotationsInfo: [AnnotationInfo]
    
    func fetchNewAnnotationsInfo(request: ManageRouteMap.FetchNewAnnotationsInfo.Request) {
        
        if let fetchedInfo = worker?.fetchNewAnnotationsInfo(comparingWith: idOfAlreadySettedRoutePoints) {
            let (addedAnnotationsInfo, idsOfRemovedRP) = fetchedInfo
            
            annotationsInfo.append(contentsOf: addedAnnotationsInfo)
            
            for id in idsOfRemovedRP {
                let indexToDelete = annotationsInfo.firstIndex(where: { return $0.id == id })
                annotationsInfo.remove(at: indexToDelete!)
            }
            
            let response = ManageRouteMap.FetchNewAnnotationsInfo.Response(newAnnotationsInfo: addedAnnotationsInfo,
                                                                           idsOfRemovedRoutePoints: idsOfRemovedRP)
            presenter?.presentFetchDifference(response: response)
        }
    }
    
    private var idOfAlreadySettedRoutePoints: [String] {
        let idList: [String]
        
        if annotationsInfo.count > 0 {
            idList = annotationsInfo.map({
                return $0.id
            })
            
            return idList
        } else {
            idList = []
            
            return idList
        }
    }
    
    // MARK: Set route point
    
    func setRoutePoint(request: ManageRouteMap.SetRoutePoint.Request) {
        let response = ManageRouteMap.SetRoutePoint.Response(annotationInfo: request.annotationsInfo)
        presenter?.presentSetRoutePoint(response: response)
    }
    
    // MARK: Select Annotation
    
    func selectAnnotation(request: ManageRouteMap.SelectAnnotation.Request) {
        idOfSelectedAnnotation = request.identifier
        let response = ManageRouteMap.SelectAnnotation.Response(identifier: idOfSelectedAnnotation)
        presenter?.presentSelectAnnotation(response: response)
    }
    
    // MARK: Deselect Annotation
    
    func deselectAnnotation(request: ManageRouteMap.DeselectAnnotation.Request) {
        selectedRoutePoint = nil
        let response = ManageRouteMap.DeselectAnnotation.Response()
        presenter?.presentDeselectAnnotation(response: response)
    }
    
    // MARK: Show Detail
    
    func showDetail(request: ManageRouteMap.ShowDetail.Request) {
        let response = ManageRouteMap.ShowDetail.Response()
        presenter?.presentShowDetail(response: response)
    }
    
    // MARK: Edit Route Point
    
    var routePointToEdit: RoutePoint?
    
    func editRoutePoint(request: ManageRouteMap.EditRoutePoint.Request) {
        idOfSelectedAnnotation = request.identifier
        let response = ManageRouteMap.EditRoutePoint.Response()
        presenter?.presentEditRoutePoint(response: response)
    }
    
    // MARK: Delete Annotation
    
//    var routePointToDelete: RoutePoint?
    
    func deleteRoutePoint(request: ManageRouteMap.DeleteAnnotation.Request) {
        let response = ManageRouteMap.DeleteAnnotation.Response(identifier: request.identifier)
        presenter?.presentDeleteRoutePoint(response: response)
    }
    
    // MARK: Create Route Fragment
    
    func createRouteFragment(request: ManageRouteMap.CreateRouteFragment.Request) {
        let startCoordinate = CLLocationCoordinate2D(
            latitude: request.addedSubrouteInfo.startWaypoint.latitude, longitude: request.addedSubrouteInfo.startWaypoint.longitude)
        let endCoordinate = CLLocationCoordinate2D(
            latitude: request.addedSubrouteInfo.endWaypoint.latitude, longitude: request.addedSubrouteInfo.endWaypoint.longitude)
        routeCreator?.calculateRoute(from: startCoordinate, to: endCoordinate, drawHandler: { routeInfo in
            if let routeInfo = routeInfo {
                let idOfNewRouteFragment = format(firstID: request.addedSubrouteInfo.startWaypoint.id,
                                              secondID: request.addedSubrouteInfo.endWaypoint.id)
                let routeFragment = ManageRouteMap.ConcreteRouteFragment(identifier: idOfNewRouteFragment, coordinates: routeInfo.coordinates, travelTimeInSeconds: routeInfo.timeInSeconds, travelDistanceInMeters: routeInfo.distanceInMeters)
                
                let response = ManageRouteMap.CreateRouteFragment.Response(routeFragment: routeFragment)
                self.presenter?.presentCreateRouteFragment(response: response)
            }
            
        })
    }
    
    // MARK: Delete Route Fragment
    
    func deleteRouteFragment(request: ManageRouteMap.DeleteRouteFragment.Request) {
        
    }
    
    // MARK: Map Route
    
    func mapRoute(request: ManageRouteMap.MapRoute.Request) {
        var addedSubroutesInfo: [ManageRouteMap.MapRoute.SubrouteInfo] = []
        let addedAnnotationsInfo = request.addedAnnotationsInfo.sorted(by: { return $0.orderNumber < $1.orderNumber})
        if addedAnnotationsInfo.count > 0 {
            // TODO: TELL HOW MUCH ROUTES WILL BE CREATED. USE NEW USE CASE: ShowLoadingView
            for annotationInfo in addedAnnotationsInfo {
                if let previousAnnotationInfo = getPreviousAnnotationInfo(by: annotationInfo.orderNumber) {
                    let subrouteInfo = createSubrouteInfo(start: previousAnnotationInfo, end: annotationInfo)
                    addedSubroutesInfo.append(subrouteInfo)
                }
            }
        }
        
        var idOfDeletedRouteFragments: [String] = []
        for id in request.idsOfDeletedRoutePoints {
            let orderNumber = worker!.fetchRoutePoint(with: id).orderNumber
            
            let previousAnnotationInfo = getPreviousAnnotationInfo(by: orderNumber)
            if let idOfPreviousPoint = previousAnnotationInfo?.id {
                idOfDeletedRouteFragments.append(format(firstID: idOfPreviousPoint, secondID: id))
            }
            
            let nextAnnotationInfo = getNextAnnotationInfo(by: orderNumber)
            if let idOfNextPoint = nextAnnotationInfo?.id {
                idOfDeletedRouteFragments.append(format(firstID: id, secondID: idOfNextPoint))
            }
            
            if let startPoint = previousAnnotationInfo, let endPoint = nextAnnotationInfo {
                let subrouteInfoForGap = createSubrouteInfo(start: startPoint, end: endPoint)
                addedSubroutesInfo.append(subrouteInfoForGap)
            }
        }
        let response = ManageRouteMap.MapRoute.Response(addedSubroutesInfo: addedSubroutesInfo,
                                                        idsOfDeletedRouteFragments: idOfDeletedRouteFragments)
        presenter?.presentMapRoute(response: response)
    }
    
    private func getPreviousAnnotationInfo(by orderNumber: Int) -> AnnotationInfo? {
        let filteredAnnotationInfo = annotationsInfo.filter({ return $0.orderNumber < orderNumber}).first
        
        if let filteredOrderNumber = filteredAnnotationInfo?.orderNumber, filteredOrderNumber < orderNumber {
            return filteredAnnotationInfo
        } else {
            return nil
        }
    }
    
    private func getNextAnnotationInfo(by orderNumber: Int) -> AnnotationInfo? {
        let filteredAnnotationInfo = annotationsInfo.filter({ return $0.orderNumber > orderNumber }).first
        
        if let filteredOrderNumber = filteredAnnotationInfo?.orderNumber, filteredOrderNumber > orderNumber {
            return filteredAnnotationInfo
        } else {
            return nil
        }
    }
    
    private func createSubrouteInfo(start: AnnotationInfo, end: AnnotationInfo) -> ManageRouteMap.MapRoute.SubrouteInfo {
        let startWaypoint = ManageRouteMap.MapRoute.Waypoint(
            id: start.id,
            latitude: start.latitude, longitude: start.longitude)
        let endWaypoint = ManageRouteMap.MapRoute.Waypoint(
            id: end.id,
            latitude: end.latitude, longitude: end.longitude)
        let subrouteInfo = ManageRouteMap.MapRoute.SubrouteInfo(startWaypoint: startWaypoint, endWaypoint: endWaypoint)
        
        return subrouteInfo
    }
}
